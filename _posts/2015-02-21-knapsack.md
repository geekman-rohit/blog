---
layout: post
title: Re-choose Knapsack Problem
cover: cover.jpg
---

A variant of the knapsack problem is where **each item can be chosen any number of times**.
I was at first worried in class: "Shit, my dynamic programming algorithm of knapsack won't work here". I spent the next hour making a recursive algorithm that solved this problem.

A few hours later, when I was thinking about the problem, I realized I had been stupid and dumb!
Not only was this easily possible, but it was possible by one simple change in the Knapsack Algorithm:



#### Knapsack Problem Algorithm:


{% highlight python %}
Kanpsack(weights,values,n,W)

for(w=0 to W) V[0,w]=0

for(i=1 to n)
	for(w=0 to W)
	if(weights[i]<=w)
		V[i,w]=max{V[i-1,w] , values[i]+V[i-1,w-weights[i]]}
	else
		V[i,w]=V[i-1,w]

Output(V[n,W])

{% endhighlight %}



#### The Implementation in Python:


{% highlight python %}

size=int(input("Enter number of items: ").strip())
Weight=int(input("Enter Max-Weight of Knapsack: ").strip())
weights=[int(n) for n in input("Enter weights: ").strip().split()]
values=[int(n) for n in input("Enter Values: ").strip().split()]
if len(weights)==len(values) and len(weights)==size:
    V=[[None for n in range(0,Weight+1)] for n in range(0,size+1)]
    for i in range(0,Weight+1):
        V[0][i]=0
    for i in range(1,size+1):
        V[i][0]=0
        for W in range(0,Weight+1):
            if(weights[i-1]<=W):
                if(values[i-1]+V[i-1][W-weights[i-1]] > V[i-1][W]):
                    V[i][W]=values[i-1]+V[i-1][W-weights[i-1]]
                else:
                    V[i][W]=V[i-1][W]
            else:
                V[i][W]=V[i-1][W]
print(V[size][Weight])




{% endhighlight %}


The same algoritm modified to allow each element to be chosen multiple times:



#### Re-Choose Knapsack Problem Algorithm:



{% highlight python %}

Re_Choose_Kanpsack(weights,values,n,W)

for(w=0 to W) V[0,w]=0

for(i=1 to n)
	for(w=0 to W)
	if(weights[i]<=w)
		V[i,w]=max{V[i-1,w] , values[i]+V[i,w-weights[i]]}
	else
		V[i,w]=V[i-1,w]

Output(V[n,W])

{% endhighlight %}



#### The Implementation in Python:




{% highlight python %}

size=int(input("Enter number of items: ").strip())
Weight=int(input("Enter Max-Weight of Knapsack: ").strip())
weights=[int(n) for n in input("Enter weights: ").strip().split()]
values=[int(n) for n in input("Enter Values: ").strip().split()]
if len(weights)==len(values) and len(weights)==size:
    V=[[None for n in range(0,Weight+1)] for n in range(0,size+1)]
    for i in range(0,Weight+1):
        V[0][i]=0
    for i in range(1,size+1):
        V[i][0]=0
        for W in range(0,Weight+1):
            if(weights[i-1]<=W):
                if(values[i-1]+V[i][W-weights[i-1]] > V[i-1][W]):
                    V[i][W]=values[i-1]+V[i][W-weights[i-1]]
                else:
                    V[i][W]=V[i-1][W]
            else:
                V[i][W]=V[i-1][W]
print(V[size][Weight])

{% endhighlight %}

